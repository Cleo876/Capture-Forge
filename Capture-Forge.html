<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CaptureForge - Direct Edition</title>
    
    <script>
        const TOOL_VERSION = '1.9.0';
    </script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #111827;
            overflow: hidden;
        }

        /* Dark theme overrides */
        .dark body {
            background-color: #111827;
            color: #f3f4f6;
        }
        
        .dark .bg-white { background-color: #1f2937; }
        .dark .bg-gray-100 { background-color: #374151; }
        .dark .text-gray-900 { color: #f9fafb; }
        .dark .text-gray-700 { color: #d1d5db; }
        .dark .text-gray-600 { color: #9ca3af; }
        .dark .text-gray-500 { color: #6b7280; }
        .dark .border-gray-200 { border-color: #4b5563; }
        .dark .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15); }

        /* Custom scrollbar - minimal and non-intrusive */
        ::-webkit-scrollbar { 
            width: 4px; 
            height: 4px;
        }
        ::-webkit-scrollbar-track { 
            background-color: transparent; 
        }
        ::-webkit-scrollbar-thumb { 
            background-color: rgba(156, 163, 175, 0.3); 
            border-radius: 2px; 
        }
        .dark ::-webkit-scrollbar-thumb { 
            background-color: rgba(75, 85, 99, 0.4); 
        }
        ::-webkit-scrollbar-thumb:hover { 
            background-color: rgba(156, 163, 175, 0.5); 
        }
        .dark ::-webkit-scrollbar-thumb:hover { 
            background-color: rgba(75, 85, 99, 0.6); 
        }

        /* Splash Screen */
        #splash-screen {
            transition: opacity 0.5s ease-in-out;
        }
        .splash-content {
            animation: fadeInUp 1s ease-out;
        }
        .splash-logo {
            font-family: 'Inter', sans-serif;
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 1px;
        }
        .splash-tagline {
            animation: fadeIn 1s ease-out 0.5s forwards;
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        
        /* Recording Indicator */
        @keyframes pulse-red {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .recording-indicator {
            animation: pulse-red 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        /* Toast notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 10000;
            transform: translateX(150%);
            transition: transform 0.3s ease;
        }
        .toast.show {
            transform: translateX(0);
        }
        .toast.success { background-color: #10B981; }
        .toast.error { background-color: #EF4444; }
        .toast.warning { background-color: #F59E0B; }
        .toast.info { background-color: #3B82F6; }
        
        /* Audio Meter Animation */
        #mic-level-bar {
            transition: width 0.05s linear, background-color 0.1s;
        }
        
        /* Countdown Overlay Animation */
        @keyframes ping-slow {
            0% { transform: scale(1); opacity: 1; }
            75%, 100% { transform: scale(1.5); opacity: 0; }
        }
        .animate-ping-slow {
            animation: ping-slow 1s cubic-bezier(0, 0, 0.2, 1) infinite;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .splash-logo {
                font-size: 2.5rem;
            }
            #app-container main {
                flex-direction: column;
            }
            .sidebar-compact {
                width: 100%;
                max-height: 40vh;
            }
        }
        
        @media (min-width: 769px) {
            .sidebar-compact {
                width: 320px;
            }
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class'
        }
    </script>
</head>
<body class="flex flex-col h-screen overflow-hidden relative">

    <!-- Toast Notifications -->
    <div id="toast-container"></div>

    <!-- Countdown Overlay -->
    <div id="countdown-overlay" class="fixed inset-0 z-[60] flex items-center justify-center bg-black/60 backdrop-blur-sm hidden">
        <div class="text-9xl font-bold text-white drop-shadow-lg" id="countdown-number">3</div>
    </div>

    <!-- Splash Screen -->
    <div id="splash-screen" class="fixed inset-0 flex flex-col justify-center items-center z-50 bg-gray-100 dark:bg-gray-900">
        <div class="splash-content text-center">
            <div class="text-5xl font-bold mb-4" style="color: #EF4444;">
                <i class="fas fa-video"></i>
            </div>
            <div class="splash-logo">[CaptureForge]</div>
            <div class="text-sm font-semibold text-gray-400 tracking-widest uppercase mt-1">Direct Edition</div>
            <div id="splash-tagline" class="splash-tagline text-xl text-gray-500 dark:text-gray-400 opacity-0 mt-2">Share, Record, and Highlight.</div>
        </div>
    </div>
    
    <!-- Mini Player / Pop Out Template (Hidden by default) -->
    <div id="mini-player-template" class="hidden">
        <div class="bg-white dark:bg-gray-900 p-3 flex flex-col gap-3 h-full">
            <!-- Header Row: Timer -->
            <div class="flex items-center justify-between border-b border-gray-100 dark:border-gray-800 pb-2">
                <div class="flex items-center gap-2">
                    <span class="text-red-600 animate-pulse text-xs"><i class="fas fa-circle"></i></span>
                    <span class="text-xl font-mono font-bold text-gray-900 dark:text-gray-100 mini-timer-display">00:00</span>
                </div>
                <div class="text-xs text-gray-400 font-semibold tracking-wider">REC</div>
            </div>
            
            <!-- Controls Row -->
            <div class="flex gap-2">
                <button class="mini-pause-btn flex-1 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 rounded-lg text-sm transition-colors">
                    <i class="fas fa-pause mr-1"></i> Pause
                </button>
                <button class="mini-stop-btn flex-1 bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 rounded-lg text-sm transition-colors">
                    <i class="fas fa-stop mr-1"></i> Stop
                </button>
            </div>
            
            <!-- Accordion Video Preview -->
            <div class="mini-video-section flex-grow flex flex-col">
                <button class="mini-toggle-preview w-full text-xs text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 py-1 flex items-center justify-center gap-1 transition-colors">
                    <span>Show Preview</span> <i class="fas fa-chevron-down transform transition-transform duration-200"></i>
                </button>
                <div class="mini-video-container hidden mt-2 rounded-lg overflow-hidden bg-black aspect-video relative flex-grow">
                    <!-- Video will be injected here -->
                    <div class="absolute inset-0 flex items-center justify-center text-gray-600">
                        <i class="fas fa-video-slash"></i>
                    </div>
                </div>
            </div>
            
            <!-- Return Button (Only shown if needed) -->
            <button class="mini-return-btn w-full mt-auto text-[10px] text-gray-400 hover:text-red-500 uppercase tracking-widest text-center py-2 border-t border-gray-100 dark:border-gray-800">
                Return to Tab
            </button>
        </div>
    </div>

    <!-- Main Application Container -->
    <div id="app-container" class="flex flex-col h-full opacity-0 transition-opacity duration-500">
        
        <!-- Header -->
        <header class="flex-shrink-0 flex justify-between items-center px-4 py-3 bg-white dark:bg-gray-800 shadow-sm z-20 border-b border-gray-200 dark:border-gray-700">
            <div class="flex items-center gap-2">
                <span class="text-2xl" style="color: #EF4444;"><i class="fas fa-video"></i></span>
                <span class="text-xl font-bold text-gray-900 dark:text-gray-100">CaptureForge</span>
                <span class="text-xs bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-100 px-2 py-1 rounded">Direct</span>
            </div>
            
            <div class="flex items-center gap-4">
                <div id="recording-status" class="hidden items-center gap-2 text-red-600 font-semibold">
                    <span class="recording-indicator w-3 h-3 bg-red-600 rounded-full"></span>
                    <span id="timer">REC 00:00</span>
                </div>
                <button id="theme-toggle" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700" title="Toggle dark mode">
                    <svg id="theme-icon-light" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>
                    <svg id="theme-icon-dark" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>
                </button>
            </div>
        </header>

        <!-- Main Content Area -->
        <main class="flex-grow flex flex-col md:flex-row h-full overflow-hidden">
            
            <!-- Controls Sidebar -->
            <aside class="sidebar-compact flex-shrink-0 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 p-4 overflow-y-auto">
                <div class="space-y-5">
                    <h2 class="text-lg font-semibold text-gray-900 dark:text-gray-100 border-b border-gray-200 dark:border-gray-700 pb-2">Controls</h2>
                    
                    <!-- Start/Stop Buttons -->
                    <div>
                        <button id="start-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2.5 px-4 rounded-lg flex items-center justify-center gap-2 transition-all text-sm">
                            <i class="fas fa-play"></i>
                            <span>Start Sharing</span>
                        </button>
                        <button id="start-recording-btn" class="w-full mt-2 bg-red-600 hover:bg-red-700 text-white font-bold py-2.5 px-4 rounded-lg flex items-center justify-center gap-2 transition-all text-sm hidden">
                            <i class="fas fa-circle"></i>
                            <span>Start Recording</span>
                        </button>
                        
                        <!-- New PiP Button -->
                        <button id="pip-btn" class="w-full mt-2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2.5 px-4 rounded-lg flex items-center justify-center gap-2 transition-all text-sm hidden">
                            <i class="fas fa-external-link-alt"></i>
                            <span>Pop Out Controls</span>
                        </button>

                        <button id="pause-resume-btn" class="w-full mt-2 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2.5 px-4 rounded-lg flex items-center justify-center gap-2 transition-all text-sm hidden">
                            <i class="fas fa-pause"></i>
                            <span>Pause</span>
                        </button>
                        <button id="stop-btn" class="w-full mt-2 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2.5 px-4 rounded-lg flex items-center justify-center gap-2 transition-all text-sm hidden">
                            <i class="fas fa-stop"></i>
                            <span>Stop</span>
                        </button>
                    </div>
                    
                    <hr class="border-gray-200 dark:border-gray-700">

                    <!-- Recording Options -->
                    <div>
                        <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">Recording Options</h3>
                        <div class="space-y-2">
                            <!-- Include Audio (Parent) -->
                            <label class="flex items-center justify-between p-2 bg-gray-100 dark:bg-gray-700 rounded-lg">
                                <span class="font-medium text-gray-900 dark:text-gray-100 text-sm">Include Audio</span>
                                <div class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="include-audio" class="sr-only peer" checked>
                                    <div class="w-9 h-5 bg-gray-300 dark:bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                                </div>
                            </label>

                            <!-- Sub-options container -->
                            <div id="audio-sub-options" class="ml-4 pl-3 border-l-2 border-gray-200 dark:border-gray-700 space-y-4 transition-all duration-300 ease-in-out">
                                
                                <!-- Microphone Section -->
                                <div>
                                    <label class="flex items-center justify-between p-2 bg-gray-100 dark:bg-gray-700 rounded-lg">
                                        <span class="font-medium text-gray-900 dark:text-gray-100 text-sm">Microphone</span>
                                        <div class="relative inline-flex items-center cursor-pointer">
                                            <input type="checkbox" id="include-mic" class="sr-only peer">
                                            <div class="w-9 h-5 bg-gray-300 dark:bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                                        </div>
                                    </label>
                                    
                                    <!-- Visual Audio Meter (New Feature) -->
                                    <div id="mic-meter-wrapper" class="hidden mt-1 mx-1">
                                        <div class="h-1.5 w-full bg-gray-200 dark:bg-gray-600 rounded-full overflow-hidden">
                                            <div id="mic-level-bar" class="h-full bg-green-500 w-0"></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Raw Audio Mode (Child of Microphone) -->
                                    <div id="raw-audio-container" class="hidden mt-2 ml-2 pl-2 border-l border-gray-300 dark:border-gray-600">
                                        <label class="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-750 rounded-lg">
                                            <span class="font-medium text-gray-700 dark:text-gray-300 text-xs">Raw Audio (Pro)</span>
                                            <div class="relative inline-flex items-center cursor-pointer">
                                                <input type="checkbox" id="raw-audio-mode" class="sr-only peer">
                                                <div class="w-8 h-4 bg-gray-300 dark:bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:bg-blue-500"></div>
                                            </div>
                                        </label>
                                    </div>
                                </div>

                                <!-- System Audio Section (Sibling of Mic) -->
                                <div>
                                    <label class="flex items-center justify-between p-2 bg-gray-100 dark:bg-gray-700 rounded-lg">
                                        <span class="font-medium text-gray-900 dark:text-gray-100 text-sm">System Audio</span>
                                        <div class="relative inline-flex items-center cursor-pointer">
                                            <input type="checkbox" id="include-sys-audio" class="sr-only peer" checked>
                                            <div class="w-9 h-5 bg-gray-300 dark:bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                                        </div>
                                    </label>
                                    <!-- Warning Note -->
                                    <div id="sys-audio-warning" class="mt-1 p-2 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded text-xs text-yellow-700 dark:text-yellow-400">
                                        <i class="fas fa-exclamation-triangle mr-1"></i> Note: Fullscreen capture often blocks system audio. Use <b>Tab</b> capture for best sound results.
                                    </div>
                                </div>

                            </div>

                        </div>
                    </div>

                    <hr class="border-gray-200 dark:border-gray-700">

                    <!-- Quality Settings -->
                    <div>
                        <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">Quality Settings</h3>
                        <div class="space-y-2">
                            <div class="p-2 bg-gray-100 dark:bg-gray-700 rounded-lg">
                                <label class="block font-medium text-gray-900 dark:text-gray-100 mb-1 text-sm">Video Quality</label>
                                <select id="video-quality" class="w-full p-1.5 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm">
                                    <option value="high">High (4K/Native)</option>
                                    <option value="medium" selected>Medium (1080p)</option>
                                    <option value="low">Low (720p)</option>
                                </select>
                            </div>
                            <div class="p-2 bg-gray-100 dark:bg-gray-700 rounded-lg">
                                <label class="block font-medium text-gray-900 dark:text-gray-100 mb-1 text-sm">Frame Rate</label>
                                <select id="frame-rate" class="w-full p-1.5 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm">
                                    <option value="60">60 FPS</option>
                                    <option value="30" selected>30 FPS</option>
                                    <option value="24">24 FPS</option>
                                    <option value="15">15 FPS</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <hr class="border-gray-200 dark:border-gray-700">
                    
                    <!-- Download Area -->
                    <div>
                        <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">Your Recording</h3>
                        <div id="download-area" class="hidden text-center">
                            <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Your recording is ready!</p>
                            <!-- Note: Changed to button behavior for IDB saving, but keeping UI exactly as is -->
                            <a id="download-link" class="cursor-pointer w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center gap-2 transition-all text-sm mb-2">
                                <i class="fas fa-download"></i>
                                <span>Download Video</span>
                            </a>
                            <button id="new-recording-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-1.5 px-4 rounded-lg flex items-center justify-center gap-2 transition-all text-xs">
                                <i class="fas fa-plus"></i>
                                <span>New Recording</span>
                            </button>
                        </div>
                        <div id="no-recording" class="text-center">
                            <p class="text-xs text-gray-500 dark:text-gray-500">Your downloaded video will appear here.</p>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Video Preview Area -->
            <div class="preview-expanded flex-grow overflow-hidden bg-gray-100 dark:bg-gray-900 flex flex-col">
                <div class="flex-grow flex items-center justify-center p-4 overflow-hidden">
                    <div id="preview-wrapper" class="w-full h-full bg-black rounded-lg shadow-lg flex items-center justify-center relative overflow-hidden max-w-6xl max-h-full">
                        <video id="video-preview" class="max-w-full max-h-full" autoplay muted playsinline></video>
                        <div id="placeholder-text" class="text-gray-500 dark:text-gray-700 text-lg text-center">
                            <i class="fas fa-desktop text-6xl mb-4"></i>
                            <p>Your screen share will appear here.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Recording Stats -->
                <div id="recording-stats" class="hidden p-3 text-center text-sm text-gray-600 dark:text-gray-400 border-t border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800">
                    <p>Recording: <span id="file-size">0 MB</span> | <span id="recording-time">00:00</span></p>
                </div>
            </div>
        </main>
        
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // === IndexedDB Logic ===
            // This handles infinite storage for hours of recording
            const VideoDB = {
                dbName: 'CaptureForgeDB',
                storeName: 'chunks',
                dbVersion: 1,
                db: null,

                async init() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName, this.dbVersion);
                        
                        request.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            if (!db.objectStoreNames.contains(this.storeName)) {
                                db.createObjectStore(this.storeName, { autoIncrement: true });
                            }
                        };
                        
                        request.onsuccess = (e) => {
                            this.db = e.target.result;
                            console.log("DB Initialized");
                            resolve();
                        };
                        
                        request.onerror = (e) => {
                            console.error("DB Error", e);
                            reject(e);
                        };
                    });
                },

                async clear() {
                    return new Promise((resolve, reject) => {
                        if (!this.db) return resolve();
                        const transaction = this.db.transaction([this.storeName], 'readwrite');
                        const store = transaction.objectStore(this.storeName);
                        const request = store.clear();
                        
                        request.onsuccess = () => resolve();
                        request.onerror = (e) => reject(e);
                    });
                },

                async addChunk(chunk) {
                    return new Promise((resolve, reject) => {
                        // Don't save empty chunks
                        if (!chunk || chunk.size === 0) return resolve();

                        const transaction = this.db.transaction([this.storeName], 'readwrite');
                        const store = transaction.objectStore(this.storeName);
                        const request = store.add(chunk);
                        
                        request.onsuccess = () => resolve();
                        request.onerror = (e) => reject(e);
                    });
                },

                // Fallback for older browsers (loads everything into RAM)
                async getAllBlobs() {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction([this.storeName], 'readonly');
                        const store = transaction.objectStore(this.storeName);
                        const request = store.getAll();
                        
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = (e) => reject(e);
                    });
                },

                // MODERN STREAMING (The "Magic" for hours of recording)
                // Pipes data from Disk (IDB) -> Disk (File System) without RAM spike
                async streamToFile(writableStream) {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction([this.storeName], 'readonly');
                        const store = transaction.objectStore(this.storeName);
                        const cursorRequest = store.openCursor();
                        
                        cursorRequest.onsuccess = async (e) => {
                            const cursor = e.target.result;
                            if (cursor) {
                                try {
                                    // Write specific chunk directly to file stream
                                    await writableStream.write(cursor.value);
                                    cursor.continue();
                                } catch (err) {
                                    reject(err);
                                }
                            } else {
                                // Done iterating
                                resolve();
                            }
                        };
                        
                        cursorRequest.onerror = (e) => reject(e);
                    });
                }
            };
            
            // === DOM Element Cache ===
            const $ = (selector) => document.querySelector(selector);
            const $$ = (selector) => document.querySelectorAll(selector);
            
            // Modals & App Containers
            const splashScreen = $('#splash-screen');
            const appContainer = $('#app-container');
            const countdownOverlay = $('#countdown-overlay');
            const countdownNumber = $('#countdown-number');
            
            // Theme
            const themeToggle = $('#theme-toggle');
            const themeIconLight = $('#theme-icon-light');
            const themeIconDark = $('#theme-icon-dark');
            
            // Buttons
            const startBtn = $('#start-btn');
            const startRecordingBtn = $('#start-recording-btn');
            const pipBtn = $('#pip-btn'); // New PiP Button
            const pauseResumeBtn = $('#pause-resume-btn');
            const stopBtn = $('#stop-btn');
            const newRecordingBtn = $('#new-recording-btn');
            
            // Options
            const includeAudioCheck = $('#include-audio'); // Master
            const audioSubOptions = $('#audio-sub-options'); // Container
            
            const includeMicCheck = $('#include-mic'); // Child 1
            const micMeterWrapper = $('#mic-meter-wrapper'); // New Meter Wrapper
            const micLevelBar = $('#mic-level-bar'); // New Meter Bar
            const rawAudioContainer = $('#raw-audio-container');
            const rawAudioCheck = $('#raw-audio-mode'); // Child 1.1
            
            const includeSysAudioCheck = $('#include-sys-audio'); // Child 2
            const sysAudioWarning = $('#sys-audio-warning');
            
            const videoQualitySelect = $('#video-quality');
            const frameRateSelect = $('#frame-rate');
            
            // Status & Preview
            const recordingStatusEl = $('#recording-status');
            const timerEl = $('#timer');
            const previewWrapper = $('#preview-wrapper');
            const videoPreview = $('#video-preview');
            const placeholderText = $('#placeholder-text');
            const recordingStats = $('#recording-stats');
            const fileSizeEl = $('#file-size');
            const recordingTimeEl = $('#recording-time');
            
            // Download Area
            const downloadArea = $('#download-area');
            const noRecording = $('#no-recording');
            const downloadLink = $('#download-link');
            
            // Mini Player Elements
            const miniPlayerTemplate = $('#mini-player-template');
            
            // === State ===
            let isSharing = false;
            let isRecording = false;
            let isPaused = false;
            let mediaRecorder;
            let micStream = null; // Persistent Mic Stream
            // let recordedChunks = []; // REPLACED BY IDB
            let displayStream; // Screen/tab stream
            // audioStream removed in favor of direct track handling
            let timerInterval;
            let secondsElapsed = 0;
            let recordingStartTime = 0;
            // -- Optimization: Add running total --
            let totalRecordedSize = 0;
            let lastMimeType = ''; // To remember type for saving
            
            // Audio Meter State
            let audioContext;
            let analyser;
            let microphoneSource;
            let meterRafId;

            // PiP State
            let pipWindow = null;

            // Browser capabilities
            const browserCapabilities = {
                screenShare: !!navigator.mediaDevices?.getDisplayMedia,
                mediaRecorder: !!window.MediaRecorder,
                fileSystem: !!window.showSaveFilePicker,
                documentPiP: 'documentPictureInPicture' in window
            };

            // === Initializers ===

            function init() {
                // Initialize DB first
                VideoDB.init().catch(e => console.error("Failed to init DB", e));

                // Show splash screen, then fade out and show app
                setTimeout(() => {
                    splashScreen.style.opacity = '0';
                    splashScreen.addEventListener('transitionend', () => {
                        splashScreen.classList.add('hidden');
                        appContainer.style.opacity = '1';
                        checkBrowserSupport();
                    }, { once: true });
                }, 1500);
                
                initTheme();
                initButtons();
                initEventListeners();
            }

            function initTheme() {
                const savedTheme = localStorage.getItem('captureforge-theme') || 'light';
                if (savedTheme === 'dark') {
                    document.documentElement.classList.add('dark');
                    themeIconLight.classList.add('hidden');
                    themeIconDark.classList.remove('hidden');
                } else {
                    document.documentElement.classList.remove('dark');
                    themeIconLight.classList.remove('hidden');
                    themeIconDark.classList.add('hidden');
                }
                
                themeToggle.addEventListener('click', () => {
                    const isDark = document.documentElement.classList.toggle('dark');
                    localStorage.setItem('captureforge-theme', isDark ? 'dark' : 'light');
                    themeIconLight.classList.toggle('hidden', isDark);
                    themeIconDark.classList.toggle('hidden', !isDark);
                });
            }

            function initButtons() {
                startBtn.addEventListener('click', startSharing);
                startRecordingBtn.addEventListener('click', startRecordingWithCountdown);
                pauseResumeBtn.addEventListener('click', togglePauseResume);
                stopBtn.addEventListener('click', stopAll);
                
                // PiP Toggle
                pipBtn.addEventListener('click', toggleMiniPlayer);
                
                newRecordingBtn.addEventListener('click', async () => {
                    await VideoDB.clear();
                    totalRecordedSize = 0;
                    resetUI();
                    downloadArea.classList.add('hidden');
                    noRecording.classList.remove('hidden');
                });

                // REPLACED: Download link now handles export logic
                downloadLink.addEventListener('click', handleDownload);
                
                // --- UI VISIBILITY LOGIC (HIERARCHY) ---
                
                // 1. Master Audio Toggle: Controls Sub-options Container
                includeAudioCheck.addEventListener('change', () => {
                    if (includeAudioCheck.checked) {
                        audioSubOptions.classList.remove('hidden');
                    } else {
                        audioSubOptions.classList.add('hidden');
                    }
                });

                // 2. Mic Toggle: Controls Raw Audio Visibility & Meter & MONITORING
                includeMicCheck.addEventListener('change', () => {
                    if (includeMicCheck.checked) {
                        rawAudioContainer.classList.remove('hidden');
                        startMicMonitoring(); // ACTIVATE MONITOR
                    } else {
                        rawAudioContainer.classList.add('hidden');
                        stopMicMonitoring(); // DEACTIVATE MONITOR
                    }
                });
                
                // 2.1 Raw Audio Toggle: Restart Monitoring
                rawAudioCheck.addEventListener('change', () => {
                    if (includeMicCheck.checked) {
                        startMicMonitoring(); // Restart to apply constraints
                    }
                });
                
                // 3. System Audio Toggle: Controls Warning Visibility
                includeSysAudioCheck.addEventListener('change', () => {
                    if (includeSysAudioCheck.checked) {
                        sysAudioWarning.classList.remove('hidden');
                    } else {
                        sysAudioWarning.classList.add('hidden');
                    }
                });

                // Initialize state
                if (!includeAudioCheck.checked) audioSubOptions.classList.add('hidden');
                if (!includeMicCheck.checked) rawAudioContainer.classList.add('hidden');
                if (!includeSysAudioCheck.checked) sysAudioWarning.classList.add('hidden');
                
                // Always show PiP button now (handled by custom logic)
                pipBtn.classList.remove('hidden');

                // --- END UI VISIBILITY LOGIC ---

                // Listeners for quality changes
                videoQualitySelect.addEventListener('change', updateStreamConstraints);
                frameRateSelect.addEventListener('change', updateStreamConstraints);
            }

            function updateStreamConstraints() {
                if (isSharing && displayStream) {
                    const track = displayStream.getVideoTracks()[0];
                    if (track && track.applyConstraints) {
                        const quality = videoQualitySelect.value;
                        const frameRate = parseInt(frameRateSelect.value);
                        
                        const constraints = {
                            width: { ideal: getQualityWidth(quality) },
                            height: { ideal: getQualityHeight(quality) },
                            frameRate: { ideal: frameRate }
                        };
                        
                        track.applyConstraints(constraints)
                            .then(() => {
                                console.log('Constraints updated successfully');
                                showToast('Quality updated', 'info');
                            })
                            .catch(e => {
                                console.warn("Constraint update failed", e);
                            });
                    }
                }
            }

            function initEventListeners() {
                window.addEventListener('beforeunload', (e) => {
                    if (isRecording) {
                        e.preventDefault();
                        e.returnValue = 'You have an active recording. Are you sure you want to leave?';
                        return e.returnValue;
                    }
                });
            }

            // === Browser Support Checks ===

            async function checkBrowserSupport() {
                if (!browserCapabilities.screenShare) {
                    showToast('Screen sharing is not supported in your browser', 'error');
                    startBtn.disabled = true;
                    return;
                }

                if (!browserCapabilities.mediaRecorder) {
                    showToast('Media recording is not supported in your browser', 'error');
                    startBtn.disabled = true;
                    return;
                }

                // Check for supported MIME types
                const supportedMimeType = getSupportedMimeType();
                if (!supportedMimeType) {
                    showToast('Your browser has limited video format support', 'warning');
                }
            }
            
            // === Mini Player Logic (Document PiP ONLY) ===
            
            async function toggleMiniPlayer() {
                if (!isSharing) {
                    showToast("Start sharing first", "warning");
                    return;
                }

                // Close if already open
                if (pipWindow) {
                    pipWindow.close();
                    pipWindow = null;
                    return;
                }
                
                // Strict Check: Document PiP (Chrome/Edge 116+)
                if (browserCapabilities.documentPiP) {
                    try {
                        pipWindow = await documentPictureInPicture.requestWindow({
                            width: 320,
                            height: 180, // Small default height
                        });
                        
                        // Setup PiP Window Content
                        setupMiniPlayerContent(pipWindow.document.body, pipWindow);
                        
                        // Copy Styles
                        [...document.styleSheets].forEach((styleSheet) => {
                            try {
                                const cssRules = [...styleSheet.cssRules].map((rule) => rule.cssText).join('');
                                const style = document.createElement('style');
                                style.textContent = cssRules;
                                pipWindow.document.head.appendChild(style);
                            } catch (e) {
                                const link = document.createElement('link');
                                link.rel = 'stylesheet';
                                link.type = styleSheet.type;
                                link.media = styleSheet.media;
                                link.href = styleSheet.href;
                                pipWindow.document.head.appendChild(link);
                            }
                        });
                        
                        // Listen for close
                        pipWindow.addEventListener("pagehide", () => {
                            pipWindow = null;
                            updateMainUIFromMini();
                            pipBtn.innerHTML = '<i class="fas fa-external-link-alt"></i><span>Pop Out Controls</span>';
                        });

                        pipBtn.innerHTML = '<i class="fas fa-compress-arrows-alt"></i><span>Restore Controls</span>';
                        
                    } catch (err) {
                        console.error("Doc PiP Error:", err);
                        showToast("Failed to launch floating window.", "error");
                    }
                } 
                else {
                     // Browser not supported
                     showToast("Floating controls require Chrome, Edge, or Opera.", "warning");
                }
            }
            
            function setupMiniPlayerContent(container, windowRef) {
                // Clone template
                const content = miniPlayerTemplate.firstElementChild.cloneNode(true);
                container.innerHTML = '';
                container.appendChild(content);
                
                // Setup styling for window body
                container.classList.add(document.documentElement.classList.contains('dark') ? 'dark' : 'light');
                if (document.documentElement.classList.contains('dark')) {
                    container.classList.add('bg-gray-900', 'text-white');
                }

                // Bind Events in Mini Player
                const pauseBtn = container.querySelector('.mini-pause-btn');
                const stopBtn = container.querySelector('.mini-stop-btn');
                const togglePreviewBtn = container.querySelector('.mini-toggle-preview');
                const videoContainer = container.querySelector('.mini-video-container');
                const returnBtn = container.querySelector('.mini-return-btn');
                const timerDisplay = container.querySelector('.mini-timer-display');
                
                // Sync Initial State
                updateMiniPlayerState(container);
                timerDisplay.textContent = timerEl.textContent.replace('REC ', '');

                // Event Listeners
                pauseBtn.addEventListener('click', () => {
                    togglePauseResume();
                    updateMiniPlayerState(container);
                });
                
                stopBtn.addEventListener('click', () => {
                    stopAll();
                    if (windowRef) windowRef.close();
                });
                
                returnBtn.addEventListener('click', () => {
                    if (windowRef) windowRef.close();
                });
                
                togglePreviewBtn.addEventListener('click', () => {
                    const isHidden = videoContainer.classList.contains('hidden');
                    if (isHidden) {
                        videoContainer.classList.remove('hidden');
                        togglePreviewBtn.innerHTML = '<span>Hide Preview</span> <i class="fas fa-chevron-up"></i>';
                        
                        // Inject Video Stream
                        if (!videoContainer.querySelector('video')) {
                            const miniVideo = document.createElement('video');
                            miniVideo.autoplay = true;
                            miniVideo.muted = true;
                            miniVideo.className = 'w-full h-full object-cover';
                            miniVideo.srcObject = displayStream;
                            videoContainer.appendChild(miniVideo);
                        }
                        
                        // Resize Window if PiP
                        if (windowRef) windowRef.resizeTo(320, 450);
                    } else {
                        videoContainer.classList.add('hidden');
                        togglePreviewBtn.innerHTML = '<span>Show Preview</span> <i class="fas fa-chevron-down"></i>';
                        // Resize Window if PiP
                        if (windowRef) windowRef.resizeTo(320, 180);
                    }
                });
            }

            function updateMiniPlayerState(container) {
                const pauseBtn = container.querySelector('.mini-pause-btn');
                
                if (isPaused) {
                    pauseBtn.innerHTML = '<i class="fas fa-play mr-1"></i> Resume';
                    pauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                    pauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                } else {
                    pauseBtn.innerHTML = '<i class="fas fa-pause mr-1"></i> Pause';
                    pauseBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                    pauseBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                }
            }
            
            function updateMainUIFromMini() {
                // Sync happened via shared state (isPaused, etc)
                // Just refresh main UI text
                 if (isPaused) {
                    pauseResumeBtn.innerHTML = '<i class="fas fa-play"></i><span>Resume</span>';
                } else {
                    pauseResumeBtn.innerHTML = '<i class="fas fa-pause"></i><span>Pause</span>';
                }
            }

            // === Audio Meter Logic ===
            
            // NEW: Mic Monitoring Functions
            async function startMicMonitoring() {
                // Stop any previous monitoring to avoid duplicates
                stopMicMonitoring();

                try {
                    const useRawAudio = rawAudioCheck.checked;
                    micStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: !useRawAudio,
                            noiseSuppression: !useRawAudio,
                            autoGainControl: !useRawAudio
                        }
                    });
                    
                    // Activate Meter immediately
                    initAudioMeter(micStream);
                    
                } catch (err) {
                    console.warn("Mic monitoring failed", err);
                    showToast("Microphone access denied", "error");
                    includeMicCheck.checked = false;
                    rawAudioContainer.classList.add('hidden');
                    micMeterWrapper.classList.add('hidden');
                }
            }

            function stopMicMonitoring() {
                if (micStream) {
                    micStream.getTracks().forEach(t => t.stop());
                    micStream = null;
                }
                stopAudioMeter();
            }

            function initAudioMeter(stream) {
                // Only start if we have an audio track
                if (!stream || stream.getAudioTracks().length === 0) return;
                
                // Clean up previous context if exists
                stopAudioMeter();

                try {
                    // Create new AudioContext
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContext();
                    
                    // Create analyser
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256; // Small size for simple volume check
                    
                    // Create source from the stream
                    microphoneSource = audioContext.createMediaStreamSource(stream);
                    microphoneSource.connect(analyser);
                    
                    // Show the meter UI
                    micMeterWrapper.classList.remove('hidden');
                    
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    
                    const drawMeter = () => {
                        // REMOVED CHECK: Allow metering even if not recording
                        // if (!isRecording && !isPaused) return; 
                        
                        analyser.getByteFrequencyData(dataArray);
                        
                        // Calculate average volume
                        let values = 0;
                        const length = dataArray.length;
                        for (let i = 0; i < length; i++) {
                            values += dataArray[i];
                        }
                        const average = values / length;
                        
                        // Map average (0-255) to percentage width
                        // Amplify slightly for visibility
                        const volumePercent = Math.min(100, (average / 60) * 100); 
                        
                        micLevelBar.style.width = `${volumePercent}%`;
                        
                        // Color feedback based on level
                        if (volumePercent > 90) {
                            micLevelBar.classList.remove('bg-green-500', 'bg-yellow-500');
                            micLevelBar.classList.add('bg-red-500');
                        } else if (volumePercent > 70) {
                             micLevelBar.classList.remove('bg-green-500', 'bg-red-500');
                            micLevelBar.classList.add('bg-yellow-500');
                        } else {
                            micLevelBar.classList.remove('bg-red-500', 'bg-yellow-500');
                            micLevelBar.classList.add('bg-green-500');
                        }

                        meterRafId = requestAnimationFrame(drawMeter);
                    };
                    
                    drawMeter();
                    
                } catch (e) {
                    console.warn("Audio meter setup failed", e);
                }
            }
            
            function stopAudioMeter() {
                if (meterRafId) cancelAnimationFrame(meterRafId);
                
                // Hide UI
                micMeterWrapper.classList.add('hidden');
                micLevelBar.style.width = '0%';
                
                if (microphoneSource) {
                    microphoneSource.disconnect();
                    microphoneSource = null;
                }
                
                if (audioContext && audioContext.state !== 'closed') {
                    audioContext.close();
                    audioContext = null;
                }
            }

            // === Core Logic ===

            async function startSharing() {
                try {
                    showToast('Select what you want to share', 'info');
                    
                    const quality = videoQualitySelect.value;
                    const frameRate = parseInt(frameRateSelect.value);
                    const useRawAudio = rawAudioCheck.checked;
                    const captureSystemAudio = includeAudioCheck.checked && includeSysAudioCheck.checked;
                    
                    const constraints = {
                        video: {
                            cursor: "always",
                            frameRate: { ideal: frameRate, max: frameRate },
                            width: { ideal: getQualityWidth(quality) },
                            height: { ideal: getQualityHeight(quality) }
                        },
                        audio: captureSystemAudio ? {
                            echoCancellation: !useRawAudio, 
                            autoGainControl: !useRawAudio,
                            noiseSuppression: !useRawAudio,
                            systemAudio: "include" 
                        } : false
                    };

                    displayStream = await navigator.mediaDevices.getDisplayMedia(constraints);
                    
                    const hasAudio = displayStream.getAudioTracks().length > 0;
                    if (captureSystemAudio && !hasAudio) {
                        showToast('System audio was not captured. Did you select a Tab?', 'warning');
                    }

                    displayStream.getVideoTracks()[0].onended = stopAll;
                    
                    isSharing = true;
                    startBtn.classList.add('hidden');
                    startRecordingBtn.classList.remove('hidden');
                    stopBtn.classList.remove('hidden');
                    // Show PiP button
                    pipBtn.classList.remove('hidden');
                    
                    placeholderText.classList.add('hidden');
                    videoPreview.classList.remove('hidden');
                    
                    videoPreview.srcObject = displayStream;
                    
                    showToast('Screen sharing started', 'success');

                } catch (err) {
                    console.error("Error starting screen share:", err);
                    
                    if (err.toString().includes('permissions policy') || err.name === 'SecurityError') {
                        showToast("Browser policy restricts sharing here. Please download file to use.", 'error');
                    } else if (err.name !== 'NotAllowedError') {
                        showToast("Could not start screen sharing: " + err.message, 'error');
                    }
                }
            }

            // NEW: Countdown Wrapper
            async function startRecordingWithCountdown() {
                if (!isSharing || !displayStream) {
                    showToast("Please start sharing your screen first.", 'warning');
                    return;
                }

                // Show Overlay
                countdownOverlay.classList.remove('hidden');
                
                // 3
                countdownNumber.textContent = "3";
                countdownNumber.classList.add('animate-ping-slow');
                
                setTimeout(() => {
                    // 2
                    countdownNumber.textContent = "2";
                    setTimeout(() => {
                        // 1
                        countdownNumber.textContent = "1";
                        setTimeout(() => {
                            // GO
                            countdownOverlay.classList.add('hidden');
                            countdownNumber.classList.remove('animate-ping-slow');
                            // Actually Start
                            startRecording();
                        }, 1000);
                    }, 1000);
                }, 1000);
            }

            async function startRecording() {
                try {
                    // Initialize DB for new session
                    await VideoDB.clear();
                    
                    // 1. Get Audio Streams
                    // audioStream = null; // Removed, we use tracks directly now
                    const audioTracks = [];

                    if (includeAudioCheck.checked && includeSysAudioCheck.checked && displayStream.getAudioTracks().length > 0) {
                        displayStream.getAudioTracks().forEach(track => audioTracks.push(track.clone()));
                    }

                    // Use Persistent Mic Stream if active
                    if (includeAudioCheck.checked && includeMicCheck.checked) {
                        // If we have a monitored stream, use it.
                        // If not (edge case), try to get it.
                        if (!micStream) {
                             await startMicMonitoring();
                        }
                        
                        if (micStream) {
                             // Clone track for recording so we don't kill monitor on stop
                             micStream.getAudioTracks().forEach(track => audioTracks.push(track.clone()));
                        }
                    }

                    // Combine all
                    const combinedStream = new MediaStream();
                    displayStream.getVideoTracks().forEach(track => combinedStream.addTrack(track));
                    audioTracks.forEach(track => combinedStream.addTrack(track));
                    
                    totalRecordedSize = 0;
                    
                    const mimeTypes = [
                        'video/mp4;codecs=h264,aac',
                        'video/webm;codecs=vp9,opus',
                        'video/webm;codecs=vp8,opus',
                        'video/webm'
                    ];
                    
                    let selectedMimeType = '';
                    for (const mimeType of mimeTypes) {
                        if (MediaRecorder.isTypeSupported(mimeType)) {
                            selectedMimeType = mimeType;
                            break;
                        }
                    }
                    
                    const options = selectedMimeType ? { mimeType: selectedMimeType } : {};
                    if (selectedMimeType.includes('video')) {
                        options.videoBitsPerSecond = getVideoBitrate(videoQualitySelect.value);
                    }
                    
                    try {
                        mediaRecorder = new MediaRecorder(combinedStream, options);
                    } catch (e) {
                        console.warn("Preferred format failed, using default:", e);
                        mediaRecorder = new MediaRecorder(combinedStream);
                    }
                    
                    lastMimeType = mediaRecorder.mimeType;

                    // === CORE CHANGE: Write to IndexedDB ===
                    mediaRecorder.ondataavailable = async (e) => {
                        if (e.data.size > 0) {
                            // Write directly to Disk (via IDB)
                            await VideoDB.addChunk(e.data);
                            
                            // Update running total
                            totalRecordedSize += e.data.size;
                            updateFileSize();
                        }
                    };

                    mediaRecorder.onstop = () => {
                        // Do NOT generate Blob here to avoid RAM crash.
                        // Just update state and UI.
                        
                        downloadArea.classList.remove('hidden');
                        noRecording.classList.add('hidden');
                        showToast('Recording saved to temporary storage', 'success');

                        // Cleanup tracks
                        // NOTE: We only stop tracks created specifically for recording.
                        // displayStream tracks are handled below if sharing stops (or we just keep sharing)
                        // Actually, original behavior was to stop sharing tracks here too? 
                        // Original code: if (displayStream) displayStream.getTracks().forEach(track => track.stop());
                        
                        // We should probably stop the recording-specific audio tracks (clones)
                        // But mediaRecorder.stop() usually releases them.
                        // Let's explicit stop combinedStream tracks
                        combinedStream.getTracks().forEach(track => track.stop());

                        // Stop Audio Meter? NO, keep monitoring if checked.
                        // stopAudioMeter(); 

                        videoPreview.srcObject = null;
                        
                        // Close PiP/Widget
                        if (pipWindow) pipWindow.close();

                        isSharing = false;
                        
                        // Also stop display stream since isSharing is false
                        if (displayStream) displayStream.getTracks().forEach(track => track.stop());
                        
                        resetUI();
                    };
                    
                    mediaRecorder.onerror = (e) => {
                        console.error('MediaRecorder error:', e);
                        showToast('Recording error occurred', 'error');
                    };
                    
                    // 4. Start Recording
                    mediaRecorder.start(2000); // 2 second chunks for safety
                    isRecording = true;
                    recordingStartTime = Date.now();
                    startRecordingBtn.classList.add('hidden');
                    pauseResumeBtn.classList.remove('hidden');
                    recordingStatusEl.classList.remove('hidden');
                    recordingStats.classList.remove('hidden');
                    startTimer();
                    
                    showToast('Recording started', 'success');

                } catch (err) {
                    console.error("Error starting recording:", err);
                    showToast("Failed to start recording: " + err.message, 'error');
                }
            }

            // === Export / Download Logic ===
            // This is where we handle the massive file extraction without crashing
            async function handleDownload(e) {
                // Prevent default anchor behavior
                e.preventDefault();
                
                showToast("Preparing download...", "info");
                
                // Determine extension
                let fileExtension = 'webm';
                if (lastMimeType.includes('mp4')) fileExtension = 'mp4';
                const filename = `CaptureForge-Tutorial-${new Date().toISOString().replace(/:/g, '-').slice(0, 19)}.${fileExtension}`;

                try {
                    // STRATEGY A: Modern Stream to Disk (Chrome/Edge/Opera)
                    if (window.showSaveFilePicker) {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: filename,
                                types: [{
                                    description: 'Video File',
                                    accept: { [lastMimeType.split(';')[0]]: [`.${fileExtension}`] }
                                }],
                            });
                            
                            const writable = await handle.createWritable();
                            showToast("Saving... Do not close tab.", "info");
                            
                            // Pipe IDB -> File System
                            await VideoDB.streamToToFile(writable);
                            await writable.close();
                            
                            showToast("File saved successfully!", "success");
                            return;
                        } catch (pickerErr) {
                            if (pickerErr.name === 'AbortError') {
                                return; // User cancelled
                            }
                            console.warn("File System API failed, falling back to Blob...", pickerErr);
                            // Fallthrough to Strategy B
                        }
                    }

                    // STRATEGY B: Legacy Blob (Firefox/Safari)
                    // Warning: Will crash RAM if > 2GB
                    showToast("Generating download link...", "info");
                    
                    const blobs = await VideoDB.getAllBlobs();
                    const fullBlob = new Blob(blobs, { type: lastMimeType });
                    
                    const url = URL.createObjectURL(fullBlob);
                    
                    // Create temporary link to trigger download
                    const tempLink = document.createElement('a');
                    tempLink.href = url;
                    tempLink.download = filename;
                    document.body.appendChild(tempLink);
                    tempLink.click();
                    document.body.removeChild(tempLink);
                    
                    // Clean up URL after delay
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                } catch (err) {
                    console.error("Download failed:", err);
                    showToast("Failed to save file: " + err.message, 'error');
                }
            }
            // Typo fix in VideoDB call above, needs to match method name
            VideoDB.streamToToFile = VideoDB.streamToFile; 

            function togglePauseResume() {
                if (!mediaRecorder) return;
                
                if (isPaused) {
                    mediaRecorder.resume();
                    pauseResumeBtn.innerHTML = '<i class="fas fa-pause"></i><span>Pause</span>';
                    startTimer();
                    showToast('Recording resumed', 'info');
                } else {
                    mediaRecorder.pause();
                    pauseResumeBtn.innerHTML = '<i class="fas fa-play"></i><span>Resume</span>';
                    stopTimer();
                    showToast('Recording paused', 'info');
                }
                
                isPaused = !isPaused;
                
                // Sync Mini Player State if open
                if (pipWindow) updateMiniPlayerState(pipWindow.document.body);
            }

            function stopAll() {
                if (isRecording && mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    stopTimer();
                    isRecording = false;
                    isPaused = false;
                    showToast('Finalizing recording...', 'info');
                    return; 
                }

                if (isSharing) {
                    if (displayStream) {
                        displayStream.getTracks().forEach(track => track.stop());
                    }
                    
                    videoPreview.srcObject = null;
                    isSharing = false;
                    resetUI();
                    showToast('Screen sharing stopped', 'info');
                }
            }
            
            function resetUI() {
                startBtn.classList.remove('hidden');
                startRecordingBtn.classList.add('hidden');
                pauseResumeBtn.classList.add('hidden');
                stopBtn.classList.add('hidden');
                pipBtn.classList.add('hidden'); // Hide PiP on reset
                
                placeholderText.classList.remove('hidden');
                videoPreview.classList.add('hidden');
                recordingStatusEl.classList.add('hidden');
                recordingStats.classList.add('hidden');
                timerEl.textContent = 'REC 00:00';
                
                isPaused = false;
                secondsElapsed = 0;
            }
            
            // === Timer & File Size ===
            
            function startTimer() {
                secondsElapsed = 0;
                timerInterval = setInterval(() => {
                    if (!isPaused) {
                        secondsElapsed++;
                        updateTimerDisplay();
                        updateRecordingTime();
                    }
                }, 1000);
            }

            function stopTimer() {
                clearInterval(timerInterval);
            }

            function updateTimerDisplay() {
                const minutes = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
                const seconds = (secondsElapsed % 60).toString().padStart(2, '0');
                const timeStr = `${minutes}:${seconds}`;
                timerEl.textContent = `REC ${timeStr}`;
                
                // Update Mini Player Timer(s) if active
                if (pipWindow) {
                    const piTimer = pipWindow.document.querySelector('.mini-timer-display');
                    if (piTimer) piTimer.textContent = timeStr;
                }
            }

            function updateRecordingTime() {
                const totalSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
                const seconds = (totalSeconds % 60).toString().padStart(2, '0');
                recordingTimeEl.textContent = `${minutes}:${seconds}`;
            }

            function updateFileSize() {
                const sizeInMB = (totalRecordedSize / (1024 * 1024)).toFixed(1);
                fileSizeEl.textContent = `${sizeInMB} MB`;
            }
            
            // === Utility Functions ===

            function getSupportedMimeType() {
                const types = [
                    'video/webm;codecs=vp9,opus',
                    'video/webm;codecs=vp8,opus',
                    'video/webm;codecs=h264,opus',
                    'video/mp4;codecs=h264,aac',
                    'video/webm',
                    'video/mp4'
                ];
                
                return types.find(type => MediaRecorder.isTypeSupported(type)) || '';
            }

            function getQualityWidth(quality) {
                switch(quality) {
                    case 'high': return 3840; 
                    case 'medium': return 1920; 
                    case 'low': return 1280; 
                    default: return 1920;
                }
            }

            function getQualityHeight(quality) {
                switch(quality) {
                    case 'high': return 2160; 
                    case 'medium': return 1080; 
                    case 'low': return 720; 
                    default: return 1080;
                }
            }

            function getVideoBitrate(quality) {
                switch(quality) {
                    case 'high': return 8000000; 
                    case 'medium': return 4000000; 
                    case 'low': return 1000000; 
                    default: return 4000000;
                }
            }

            function showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                
                const icon = document.createElement('i');
                icon.className = `fas ${
                    type === 'success' ? 'fa-check-circle' :
                    type === 'error' ? 'fa-exclamation-circle' :
                    type === 'warning' ? 'fa-exclamation-triangle' :
                    'fa-info-circle'
                } mr-2`;
                
                toast.prepend(icon);
                $('#toast-container').appendChild(toast);
                
                setTimeout(() => toast.classList.add('show'), 100);
                
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => toast.remove(), 300);
                }, 5000);
            }

            init();
        });
    </script>

</body>
</html>
